/*
 * This template demonstrates how an exploit for a heap based
 * buffer overflow could be structured. Feel free to use it, or
 * write your own from scratch.
 *
 * The code does NOT match c4288bb0f38c68dd2258b0b941ccbb4534e286d5;
 * it is just a template and you need to change most of it.
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

unsigned char shellcode[] = {
#include "www-shellcode.h"
};

int main(void)
{
	struct _chunk {
		uint32_t fd;
		uint32_t bk;
		/* ... */
		unsigned char nul;  /* terminate string */
	} __attribute__((packed)) chunk;
	char long_param[5000];
	
	char *argv[] = { 	"./c4288bb0f38c68dd2258b0b941ccbb4534e286d5", 
						"-read", 
						"demo.bmp",
						(char *)&chunk, 
						NULL };

	memset(&chunk, 'A', sizeof(chunk));

	/* ... */

	/* terminate the string */
	chunk.nul = '\0';

	execve(argv[0], argv, NULL);

	return EXIT_FAILURE;
}


void createBMP(int height, int width)
{
	struct _bmpheader {
		char[2] bfType; // Must be BM
		char[4] bfSize; // Size of the bitmap file
		char[4] reserved;
		char[4] bfHeader; // Size of the bitmap header
	} bmpheader;

	struct _bmpinfoheader {
		char[4] bfSize;  // Size of the bitmap
		char[4] bmwidth; // Width
		char[4] bmheight; // Height
		char[2] planes; // Number of color planes
		char[4] rawSize; // Size of raw bitmap data
	} bmpinfoheader;

	int header_size = 54;
	int raw_offset = 40;
	int bits_per_pixel = 24;
	int row_size = 4 * ((bits_per_pixel * width) / 32)
	int file_size = 54 + (4 * (bits_per_pixel ** 2)) + (row_size * height)
	int raw_size = file_size - headersize;

	memset(&bmpheader, NULL, sizeof(bmpheader));
	memset(&bmpinfoheader, NULL, sizeof(bmpinfoheader));




}